{
  "version": 3,
  "sources": ["../../svelte-spa-router/active.js"],
  "sourcesContent": ["import {parse} from 'regexparam'\r\nimport {loc} from './Router.svelte'\r\n\r\n// List of nodes to update\r\nconst nodes = []\r\n\r\n// Current location\r\nlet location\r\n\r\n// Function that updates all nodes marking the active ones\r\nfunction checkActive(el) {\r\n    const matchesLocation = el.pattern.test(location)\r\n    toggleClasses(el, el.className, matchesLocation)\r\n    toggleClasses(el, el.inactiveClassName, !matchesLocation)\r\n}\r\n\r\nfunction toggleClasses(el, className, shouldAdd) {\r\n    (className || '').split(' ').forEach((cls) => {\r\n        if (!cls) {\r\n            return\r\n        }\r\n        // Remove the class firsts\r\n        el.node.classList.remove(cls)\r\n\r\n        // If the pattern doesn't match, then set the class\r\n        if (shouldAdd) {\r\n            el.node.classList.add(cls)\r\n        }\r\n    })\r\n}\r\n\r\n// Listen to changes in the location\r\nloc.subscribe((value) => {\r\n    // Update the location\r\n    location = value.location + (value.querystring ? '?' + value.querystring : '')\r\n\r\n    // Update all nodes\r\n    nodes.map(checkActive)\r\n})\r\n\r\n/**\r\n * @typedef {Object} ActiveOptions\r\n * @property {string|RegExp} [path] - Path expression that makes the link active when matched (must start with '/' or '*'); default is the link's href\r\n * @property {string} [className] - CSS class to apply to the element when active; default value is \"active\"\r\n */\r\n\r\n/**\r\n * Svelte Action for automatically adding the \"active\" class to elements (links, or any other DOM element) when the current location matches a certain path.\r\n * \r\n * @param {HTMLElement} node - The target node (automatically set by Svelte)\r\n * @param {ActiveOptions|string|RegExp} [opts] - Can be an object of type ActiveOptions, or a string (or regular expressions) representing ActiveOptions.path.\r\n * @returns {{destroy: function(): void}} Destroy function\r\n */\r\nexport default function active(node, opts) {\r\n    // Check options\r\n    if (opts && (typeof opts == 'string' || (typeof opts == 'object' && opts instanceof RegExp))) {\r\n        // Interpret strings and regular expressions as opts.path\r\n        opts = {\r\n            path: opts\r\n        }\r\n    }\r\n    else {\r\n        // Ensure opts is a dictionary\r\n        opts = opts || {}\r\n    }\r\n\r\n    // Path defaults to link target\r\n    if (!opts.path && node.hasAttribute('href')) {\r\n        opts.path = node.getAttribute('href')\r\n        if (opts.path && opts.path.length > 1 && opts.path.charAt(0) == '#') {\r\n            opts.path = opts.path.substring(1)\r\n        }\r\n    }\r\n\r\n    // Default class name\r\n    if (!opts.className) {\r\n        opts.className = 'active'\r\n    }\r\n\r\n    // If path is a string, it must start with '/' or '*'\r\n    if (!opts.path || \r\n        typeof opts.path == 'string' && (opts.path.length < 1 || (opts.path.charAt(0) != '/' && opts.path.charAt(0) != '*'))\r\n    ) {\r\n        throw Error('Invalid value for \"path\" argument')\r\n    }\r\n\r\n    // If path is not a regular expression already, make it\r\n    const {pattern} = typeof opts.path == 'string' ?\r\n        parse(opts.path) :\r\n        {pattern: opts.path}\r\n\r\n    // Add the node to the list\r\n    const el = {\r\n        node,\r\n        className: opts.className,\r\n        inactiveClassName: opts.inactiveClassName,\r\n        pattern\r\n    }\r\n    nodes.push(el)\r\n\r\n    // Trigger the action right away\r\n    checkActive(el)\r\n\r\n    return {\r\n        // When the element is destroyed, remove it from the list\r\n        destroy() {\r\n            nodes.splice(nodes.indexOf(el), 1)\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;AAIA,IAAM,QAAQ,CAAC;AAGf,IAAI;AAGJ,SAAS,YAAY,IAAI;AACrB,QAAM,kBAAkB,GAAG,QAAQ,KAAK,QAAQ;AAChD,gBAAc,IAAI,GAAG,WAAW,eAAe;AAC/C,gBAAc,IAAI,GAAG,mBAAmB,CAAC,eAAe;AAC5D;AAEA,SAAS,cAAc,IAAI,WAAW,WAAW;AAC7C,GAAC,aAAa,IAAI,MAAM,GAAG,EAAE,QAAQ,CAAC,QAAQ;AAC1C,QAAI,CAAC,KAAK;AACN;AAAA,IACJ;AAEA,OAAG,KAAK,UAAU,OAAO,GAAG;AAG5B,QAAI,WAAW;AACX,SAAG,KAAK,UAAU,IAAI,GAAG;AAAA,IAC7B;AAAA,EACJ,CAAC;AACL;AAGA,IAAI,UAAU,CAAC,UAAU;AAErB,aAAW,MAAM,YAAY,MAAM,cAAc,MAAM,MAAM,cAAc;AAG3E,QAAM,IAAI,WAAW;AACzB,CAAC;AAec,SAAR,OAAwB,MAAM,MAAM;AAEvC,MAAI,SAAS,OAAO,QAAQ,YAAa,OAAO,QAAQ,YAAY,gBAAgB,SAAU;AAE1F,WAAO;AAAA,MACH,MAAM;AAAA,IACV;AAAA,EACJ,OACK;AAED,WAAO,QAAQ,CAAC;AAAA,EACpB;AAGA,MAAI,CAAC,KAAK,QAAQ,KAAK,aAAa,MAAM,GAAG;AACzC,SAAK,OAAO,KAAK,aAAa,MAAM;AACpC,QAAI,KAAK,QAAQ,KAAK,KAAK,SAAS,KAAK,KAAK,KAAK,OAAO,CAAC,KAAK,KAAK;AACjE,WAAK,OAAO,KAAK,KAAK,UAAU,CAAC;AAAA,IACrC;AAAA,EACJ;AAGA,MAAI,CAAC,KAAK,WAAW;AACjB,SAAK,YAAY;AAAA,EACrB;AAGA,MAAI,CAAC,KAAK,QACN,OAAO,KAAK,QAAQ,aAAa,KAAK,KAAK,SAAS,KAAM,KAAK,KAAK,OAAO,CAAC,KAAK,OAAO,KAAK,KAAK,OAAO,CAAC,KAAK,MACjH;AACE,UAAM,MAAM,mCAAmC;AAAA,EACnD;AAGA,QAAM,EAAC,QAAO,IAAI,OAAO,KAAK,QAAQ,WAClC,MAAM,KAAK,IAAI,IACf,EAAC,SAAS,KAAK,KAAI;AAGvB,QAAM,KAAK;AAAA,IACP;AAAA,IACA,WAAW,KAAK;AAAA,IAChB,mBAAmB,KAAK;AAAA,IACxB;AAAA,EACJ;AACA,QAAM,KAAK,EAAE;AAGb,cAAY,EAAE;AAEd,SAAO;AAAA;AAAA,IAEH,UAAU;AACN,YAAM,OAAO,MAAM,QAAQ,EAAE,GAAG,CAAC;AAAA,IACrC;AAAA,EACJ;AACJ;",
  "names": []
}
